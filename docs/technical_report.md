# سیستم مینی کانتینر - گزارش فنی

## ۱. مقدمه

این گزارش فنی پیاده‌سازی سیستم مینی کانتینر مشابه داکر را توصیف می‌کند که به عنوان پروژه درس سیستم‌عامل طراحی شده است. سیستم از C به C++ تبدیل شده و مفاهیم اصلی سیستم‌عامل شامل ایزولاسیون فرایند، مدیریت منابع هسته و فراخوانی‌های سیستمی را نشان می‌دهد، در حالی که روش‌های برنامه‌نویسی مدرن C++ را به نمایش می‌گذارد.

## ۲. معماری سیستم

سیستم به کامپوننت‌های مدولار سازماندهی شده است که هر کدام جنبه خاصی از کانتینری‌سازی را مدیریت می‌کنند. پیاده‌سازی C++ API سازگار با C را برای عملیات سطح سیستم حفظ می‌کند در حالی که ویژگی‌های مدرن C++ را برای بهبود مدیریت حافظه و ایمنی کد معرفی می‌کند.

### ۲.۱ کامپوننت‌های اصلی

- **مدیریت‌کننده کانتینر**: عملیات چرخه حیات کانتینر را هماهنگ می‌کند
- **مدیریت‌کننده فضای نام**: فضای نام لینوکس را برای ایزولاسیون فرایند مدیریت می‌کند
- **مدیریت‌کننده منابع**: محدودیت‌های CPU و حافظه را با استفاده از cgroups کنترل می‌کند
- **مدیریت‌کننده فایل‌سیستم**: ایزولاسیون فایل‌سیستم را از طریق chroot/pivot_root فراهم می‌کند
- **رابط CLI**: رابط خط فرمان برای تعامل کاربر

### ۲.۲ تعامل کامپوننت‌ها

```
رابط CLI
    ↓
مدیریت‌کننده کانتینر ←→ مدیریت‌کننده منابع
    ↓              ←→ مدیریت‌کننده فایل‌سیستم
مدیریت‌کننده فضای نام
```

## ۳. فضای نام لینوکس - ایزولاسیون فرایند

### ۳.۱ مفاهیم فضای نام

فضای نام لینوکس انواع مختلفی از ایزولاسیون را با مجازی‌سازی منابع سیستم فراهم می‌کنند:

- **فضای نام PID**: شناسه فرایندها را ایزوله می‌کند و به هر کانتینر درخت فرایند خود را از PID 1 می‌دهد
- **فضای نام Mount**: نقاط mount فایل‌سیستم را ایزوله می‌کند و امکان جداول mount خصوصی را می‌دهد
- **فضای نام UTS**: نام میزبان و نام دامنه را ایزوله می‌کند
- **فضای نام Network**: رابط‌های شبکه، جداول مسیریابی و قوانین فایروال را ایزوله می‌کند
- **فضای نام User**: نگاشت‌های شناسه کاربر و گروه را ایزوله می‌کند

### ۳.۲ جزئیات پیاده‌سازی

مدیریت‌کننده فضای نام از فراخوانی سیستمی `clone()` با پرچم‌های فضای نام استفاده می‌کند:

```cpp
pid_t pid = clone(child_func, stack, CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWUTS, args);
```

جنبه‌های کلیدی پیاده‌سازی:
- **تخصیص پشته**: فرایندهای فرزند نیاز به فضای پشته خود دارند
- **تنظیم فضای نام**: تابع فرزند ایزولاسیون را پس از ایجاد فضای نام پیکربندی می‌کند
- **فضای نام PID**: ایزولاسیون شناسه فرایند از PID 1 فراهم می‌کند
- **فضای نام Mount**: امکان نمایش‌های خصوصی فایل‌سیستم را می‌دهد
- **فضای نام UTS**: امکان نام‌های میزبان سفارشی برای هر کانتینر را فعال می‌کند

### ۳.۳ پیوستن به فضای نام

برای اجرای دستورات در کانتینرهای موجود، سیستم به فضای نام موجود می‌پیوندد:

```c
int namespace_join(pid_t target_pid, int ns_type) {
    // باز کردن فایل فضای نام از /proc/<pid>/ns/<type>
    // نوشتن در فایل فضای نام فرایند فعلی
}
```

## ۴. گروه‌های کنترل (cgroups) - مدیریت منابع

### ۴.۱ مفاهیم Cgroup

گروه‌های کنترل محدودیت‌های سلسله مراتبی منابع و حسابداری فراهم می‌کنند:

- **کنترل CPU**: استفاده از CPU را از طریق shares و quotas محدود می‌کند
- **کنترل حافظه**: استفاده از حافظه را با محدودیت‌های سخت و کنترل swap محدود می‌کند
- **سلسله مراتب**: ساختار درختی امکان کنترل منابع تو در تو را می‌دهد
- **حسابداری**: استفاده از منابع را برای هر گروه ردیابی می‌کند

### ۴.۲ جزئیات پیاده‌سازی

مدیریت‌کننده منابع با فایل‌سیستم `/sys/fs/cgroup` تعامل می‌کند:

```c
// ایجاد cgroup
mkdir("/sys/fs/cgroup/cpu/mini_container/container_id", 0755);

// تنظیم CPU shares
FILE *fp = fopen("/sys/fs/cgroup/cpu/mini_container/container_id/cpu.shares", "w");
fprintf(fp, "%d\n", shares);

// افزودن فرایند به cgroup
fp = fopen("/sys/fs/cgroup/cpu/mini_container/container_id/tasks", "w");
fprintf(fp, "%d\n", pid);
```

### ۴.۳ محدودیت‌های منابع

- **CPU Shares**: وزن نسبی برای زمان‌بندی CPU (پیش‌فرض: ۱۰۲۴)
- **CPU Quota**: محدودیت‌های مطلق زمان CPU (میکروثانیه در هر دوره)
- **محدودیت‌های حافظه**: محدودیت‌های سخت حافظه به بایت
- **محدودیت‌های Swap**: کنترل فضای swap

## ۵. ایزولاسیون فایل‌سیستم

### ۵.۱ Chroot در برابر Pivot Root

دو روش برای ایزولاسیون فایل‌سیستم:

- **chroot()**: دایرکتوری ریشه را برای فرایند فعلی تغییر می‌دهد
- **pivot_root()**: امن‌تر، امکان unmount کردن فایل‌سیستم ریشه قدیمی را می‌دهد

### ۵.۲ پیاده‌سازی

```c
int fs_setup_chroot(const char *root_path) {
    chdir(root_path);
    return chroot(root_path);
}
```

### ۵.۳ ایجاد فایل‌سیستم ریشه

سیستم فایل‌سیستم‌های ریشه کانتینر حداقل ایجاد می‌کند:

- دایرکتوری‌های ضروری: `/bin`, `/lib`, `/proc`, `/sys`, `/dev`
- گره‌های دستگاه: `/dev/null`, `/dev/zero`, `/dev/random`
- فایل‌های پیکربندی پایه: `/etc/passwd`, `/etc/group`

## ۶. فراخوانی‌های سیستمی و تعامل با هسته

### ۶.۱ فراخوانی‌های سیستمی اصلی

- **clone()**: فرایندهای جدید را در فضای نام ایجاد می‌کند
- **unshare()**: فرایندهای موجود را به فضای نام جدید منتقل می‌کند
- **chroot()**: دایرکتوری ریشه را تغییر می‌دهد
- **pivot_root()**: تعویض ریشه پیشرفته
- **mount()**: عملیات mount فایل‌سیستم

### ۶.۲ رابط مستقیم هسته

بر خلاف داکر، این سیستم به طور مستقیم با موارد زیر تعامل می‌کند:
- `/sys/fs/cgroup` برای مدیریت منابع
- `/proc/<pid>/ns/` برای عملیات فضای نام
- فراخوانی‌های سیستمی بدون تجرید سطح بالا

## ۷. مدیریت چرخه حیات کانتینر

### ۷.۱ وضعیت‌های کانتینر

- **CREATED**: کانتینر تعریف شده اما در حال اجرا نیست
- **RUNNING**: فرایند کانتینر فعال است
- **STOPPED**: فرایند کانتینر خاتمه یافته
- **DESTROYED**: منابع کانتینر پاکسازی شده

### ۷.۲ عملیات چرخه حیات

- **Create**: تنظیم cgroups، فضای نام، فایل‌سیستم
- **Start**: راه‌اندازی فرایند کانتینر با ایزولاسیون
- **Stop**: خاتمه فرایند کانتینر به طور graceful
- **Destroy**: پاکسازی همه منابع

## ۸. مقایسه با ماشین‌های مجازی

### ۸.۱ کانتینر در برابر VM

| جنبه | کانتینرها | ماشین‌های مجازی |
|-------|-----------|------------------|
| **ایزولاسیون** | ایزولاسیون فرایند سطح هسته | مجازی‌سازی سخت‌افزار |
| **استفاده از منابع** | هسته مشترک، سربار حداقل | سیستم‌عامل کامل برای هر VM |
| **زمان راه‌اندازی** | ثانیه | دقیقه |
| **اندازه ایمیج** | مگابایت | گیگابایت |
| **امنیت** | ایزولاسیون سطح هسته | ایزولاسیون سطح سخت‌افزار |

### ۸.۲ تفاوت‌های کلیدی

- **هسته مشترک**: کانتینرها هسته میزبان را به اشتراک می‌گذارند، VMها هسته خود را دارند
- **فراخوانی‌های سیستمی**: فراخوانی‌های سیستمی کانتینر مستقیماً به هسته میزبان می‌روند
- **کارایی منابع**: کانتینرها سربار منابع حداقل دارند
- **تراکم**: کانتینرهای بسیار بیشتری در هر میزبان نسبت به VMها

## ۹. ملاحظات امنیتی

### ۹.۱ سطوح ایزولاسیون

- **ایزولاسیون فرایند**: فضای نام PID از تداخل فرایند جلوگیری می‌کنند
- **ایزولاسیون فایل‌سیستم**: chroot/pivot_root از دسترسی فایل‌سیستم جلوگیری می‌کنند
- **ایزولاسیون شبکه**: جداسازی فضای نام شبکه اختیاری
- **ایزولاسیون کاربر**: فضای نام کاربر اختیاری برای جداسازی امتیازات

### ۹.۲ محدودیت‌ها

- **هسته مشترک**: همه کانتینرها هسته یکسانی را به اشتراک می‌گذارند
- **دسترسی روت**: کانتینرها معمولاً به عنوان روت در داخل اجرا می‌شوند
- **بدون مجازی‌سازی سخت‌افزار**: هیچ لایه امنیتی اضافی وجود ندارد

## ۱۰. ویژگی‌های عملکرد

### ۱۰.۱ زمان راه‌اندازی

- **ایجاد کانتینر**: ~۱۰۰ms (تنظیم cgroup و فضای نام)
- **راه‌اندازی فرایند**: ~۱۰ms (فراخوانی سیستمی clone)
- **مجموع**: ~۱-۲ ثانیه برای راه‌اندازی کامل کانتینر

### ۱۰.۲ سربار منابع

- **حافظه**: ~۱-۲MB برای هر کانتینر (سربار فضای نام و cgroup)
- **CPU**: سربار CPU حداقل برای حسابداری منابع
- **دیسک**: استفاده حداقل دیسک برای فایل‌سیستم cgroup

### ۱۰.۳ مقیاس‌پذیری

- **تراکم کانتینر**: محدود به PIDهای موجود و حافظه
- **محدودیت منابع**: cgroups کنترل دانه‌ریز فراهم می‌کنند
- **تعویض زمینه**: همان زمان‌بندی فرایند منظم

## ۱۱. چالش‌های پیاده‌سازی

### ۱۱.۱ چالش‌های فنی

- **هماهنگی فضای نام**: اطمینان از ترتیب صحیح تنظیم فضای نام
- **سلسله مراتب Cgroup**: مدیریت مجوزهای فایل‌سیستم cgroup
- **تنظیم فایل‌سیستم**: ایجاد فایل‌سیستم‌های ریشه حداقل کاربردی
- **همگام‌سازی فرایند**: مدیریت روابط فرایند پدر-فرزند

### ۱۱.۲ ویژگی‌های خاص لینوکس

- **وابستگی به نسخه هسته**: نیاز به ویژگی‌های هسته مدرن
- **امتیازات روت**: اکثر عملیات نیاز به دسترسی روت دارند
- **مجوزهای فایل‌سیستم**: cgroups نیاز به تنظیم mount مناسب دارند

## ۱۲. ویژگی‌های پیاده‌سازی C++

تبدیل به C++ چندین روش برنامه‌نویسی مدرن را معرفی می‌کند در حالی که سازگاری سطح سیستم را حفظ می‌کند:

### ۱۲.۱ مدیریت حافظه
- **اشاره‌گرهای هوشمند**: استفاده از `std::unique_ptr` برای مدیریت خودکار حافظه
- **الگوی RAII**: دستیابی و پاکسازی منابع از طریق عمر اشیاء
- **عملیات حافظه امن**: castهای C++ (`static_cast`, `const_cast`) به جای castهای سبک C

### ۱۲.۲ ایمنی کد
- **ایمنی نوع**: بررسی نوع قوی‌تر و تشخیص خطای زمان کامپایل
- **ایمنی استثناء**: مدیریت خطای ساختار یافته (هرچند استثناء حداقل برای سازگاری سیستم استفاده شده)
- **درستی const**: استفاده مناسب از qualifiers `const` برای داده‌های تغییرناپذیر

### ۱۲.۳ ویژگی‌های مدرن C++
- **استاندارد C++11**: استفاده از ویژگی‌های زبان مدرن و کتابخانه استاندارد
- **Header Guards**: include guards به‌روزرسانی شده برای سازگاری C++
- **Overload توابع**: پتانسیل برای بهبودهای آینده API
- **Template Metaprogramming**: فرصت‌ها برای ابزارهای generic

### ۱۲.۴ سازگاری API
- **پیوند C**: اعلانات `extern "C"` سازگاری API C را حفظ می‌کنند
- **رابط فراخوانی سیستمی**: استفاده فراخوانی سیستمی سطح پایین بدون تغییر
- **سازگاری ساختار داده**: ساختارهای سبک C برای رابط‌های هسته حفظ شده‌اند

## ۱۳. نتیجه‌گیری

این سیستم مینی کانتینر با موفقیت مفاهیم اصلی سیستم‌عامل را نشان می‌دهد:

- **ایزولاسیون فرایند**: از طریق فضای نام لینوکس
- **مدیریت منابع**: از طریق گروه‌های کنترل
- **امنیت فایل‌سیستم**: با استفاده از chroot/pivot_root
- **استفاده از فراخوانی‌های سیستمی**: تعامل مستقیم با هسته

پیاده‌سازی جایگزین سبک و آموزشی برای سیستم‌های کانتینر کامل مانند داکر فراهم می‌کند، در حالی که ویژگی‌های اساسی ایزولاسیون و مدیریت منابع را که کانتینرها را برای استقرار برنامه و ایزولاسیون اجرا مفید می‌کنند، حفظ می‌کند.

## ۱۳. بهبودهای آینده

بهبودهای احتمالی برای سیستم عملیاتی:

- **فضای نام شبکه**: پیاده‌سازی کامل ایزولاسیون شبکه
- **فضای نام کاربر**: نگاشت کامل شناسه کاربر
- **مدیریت ایمیج**: ایجاد و توزیع ایمیج کانتینر
- **Checkpoint/Restore**: ماندگاری وضعیت کانتینر
- **تقویت امنیتی**: ویژگی‌های امنیتی اضافی (seccomp, capabilities)

---

این پیاده‌سازی به عنوان ابزار آموزشی عالی برای درک مکانیزم‌های سطح پایین که پلتفرم‌های کانتینری مدرن را تامین می‌کنند، عمل می‌کند.
