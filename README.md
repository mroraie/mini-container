# مینی کانتینر (Mini Container)
				پروژه درس سیستم های عامل ترم 4041 - محمدرضا اورعی
![لوگو مینی کانتینر](imgs/mini-continer.png)

این پروژه، پروژه نهایی درس سیستم های عامل می باشد که یک پیاده‌سازی ساده از کانتینرها (مانند عملکرد داکر) با استفاده از قابلیت‌های هسته لینوکس است. هدف این پروژه بررسی و استفاده از مفاهیم سیستم‌عامل مانند ایزولاسیون فرایند و مدیریت منابع می باشد.
در این پروژه سعی شده است که پیاده‌سازی سبک یک کانتینر شبیه سازی شود که مفاهیم اصلی سیستم‌عامل را نشان می‌دهد شامل ایزولاسیون فرایند، مدیریت منابع و امنیت فایل‌سیستم.این سیستم به طور مستقیم با مکانیزم‌های هسته لینوکس تعامل می‌کند و از فراخوانی‌های سیستمی و رابط‌های هسته استفاده می‌کند.

## ویژگی‌های کلیدی
* **ایزولاسیون فرایند**: استفاده از Linux Namespaces (PID, Mount, Network, User).
* **مدیریت منابع**: کنترل میزان مصرف CPU و RAM با استفاده از Cgroups و پیاده سازی آن توسط زبان برنامه نویسی C++.
* **امنیت فایل‌سیستم**: استفاده از `chroot` (Change Root)برای محدودسازی دسترسی به دایرکتوری ها.
* **مدیریت چرخه حیات**: قابلیت ایجاد، شروع، توقف و حذف کانتینر. (در این پروژه کانتینر ها به صورت State-Base پیاده سازی شده اند و هر کانتینتر برای Valid بودن و وجود داشتن باید در یکی از این حالت ها باشد.)
* **رابط کاربری**: دارای خط فرمان (CLI) و رابط گرافیکی ترمینالی (TUI) و نمایش در وب سرور (مانند عملکرد دستور `htop` در لینوکس) می باشد.

## پیش‌نیازها برای اجرا
* **هسته لینوکس**: نسخه ۳.۸ یا بالاتر.
* **کامپایلر**: GCC (g++) با پشتیبانی از C++11.
* **دسترسی**: اجرای دستورات با سطح دسترسی `root` یا `sudo`.
* **تقسیم منابع با Cgroups**: باید در مسیر `/sys/fs/cgroup` مونت شده باشد.

## نصب و راه‌اندازی

کامپایل پروژه:
```bash
git clone https://github.com/mroraie/mini-container.git
cd mini-container
make clean
make
./mini-container
```

## نحوه استفاده

### 1) رابط گرافیکی ترمینال

برای تجربه بصری مدیریت کانتینرها:

```bash
./mini-container-ui

```
### 2) دستورات خط فرمان (CLI)
* **اجرای یک دستور ساده در کانتینر:** اجرای این دستور ساده مصرف cpu و ram بسیار کمی دارد و اصلا مشخص نمی کند که سیستم در چه وضعیتی هست، اجرای این دستور جهت بررسی صحیح بودن نصب پروژه می باشد.
`./mini-container run /bin/echo "Hello World"`
* **اجرا با محدودیت منابع:**
`./mini-container run --memory 128 --cpu 512 /bin/sh`
در این مثال از تمام فضای حافظه ای که داریم 128 مگابایت به این برانه و این دستور اختصاص داده ایم و از کل 1024 توان پردازشی سیستم خود، 528 قسمت یعنی چیزی حدود نیمی از یک هسته کامل را برای اجرای این برنامه اختصاص داده ایم.
* **مشاهده وضعیت:**
`./mini-container list`
`./mini-container info <container_id>`
با زدن این دستورات در ترمینال می توان وضعیت هر کانتینر و اطلاعات مربوط به تمام کانتینر ها را مشاهده کرد.
* **توقف و حذف:**
`./mini-container stop <container_id>`
`./mini-container destroy <container_id>`

### 3) نمایش در وب سرور



## مفاهیم سیستم‌عامل به کار رفته

### ۱. Linux Namespaces

این تکنولوژی باعث می‌شود فرایند داخل کانتینر فکر کند سیستم کاملاً متعلق به خودش می باشد و کانتینر دیگری در حال اجرا نمی باشد:

* **PID**: فرایندها فقط خودشان را می‌بینند.
* **Mount**: فایل‌سیستم ایزوله.
* **Network**: کارت شبکه مجازی مستقل.

### ۲. Control Groups (Cgroups)

برای جلوگیری از مصرف تمام منابع سیستم توسط یک کانتینر:

* **CPU**: تعیین سهمیه پردازش.
* **Memory**: تعیین سقف مصرف رم و Swap.

### ۳. فراخوانی‌های سیستمی (System Calls)

* `clone()`: برای ایجاد فرایند جدید با فضاهای نام مشخص.
* `unshare()`: برای جدا کردن بخش‌های مشترک فرایند.
* `mount()` و `chroot()`: برای ایزولاسیون دایرکتوری‌ها.


## مقایسه مینی کانتینر با داکر (Docker)
برای ساخت این پروژه از داکر الهام گرفته شده است و در طراحی و پیاده سازی سعی شده است که مفاهیم اولیه ای از داکر در این پروژه استفاده شود:

| ویژگی | مینی کانتینر | Docker |
| --- | --- | --- |
| **ایزولاسیون** | فضای نام هسته (Namespace) | فضای نام + لایه‌های امنیتی اضافی |
| **مدیریت منابع** | cgroups ساده | cgroups پیشرفته + سهمیه‌بندی دقیق |
| **فایل‌سیستم** | chroot ساده | سیستم لایه‌ای (OverlayFS) |
| **شبکه** | فضای نام پایه | پل‌های مجازی (Bridge) و شبکه پیچیده |
| **پیچیدگی** | بسیار کم (آموزشی) | بالا (صنعتی) |

## تست‌های عملکرد

برای اطمینان از ایزولاسیون، می‌توانید تست‌های زیر را داخل کانتینر اجرا کنید:

* **تست فشار CPU:**
این دستور بدون هیچ محدودیت ای کل توان cpu را برای خودش در نظر می گیرد و امکان کرش شدن سرور در این حالت وجود دارد:
```
./mini-container run sh -c 'while true; do :; done'
```
اما این دستور کل توان را به cpu نمی دهد بلکه فقط 1/4 توان یک هسته را در اختیار اجرای این برنامه قرار می دهد:
```
./mini-container run --cpu 256 sh -c 'while true; do :; done'

```
بعضی دستورات پیشرفته تر برای تست عملکرد cpu: 

```
./mini-container run --cpu 512 sh -c 'while true; do echo $((12345*67890)) > /dev/null; done'
```


* **تست محدودیت حافظه:**
`dd if=/dev/zero of=/tmp/mem bs=1M count=80`


دستور برای اختصاص دادن 256 مگ از فضای حافظه:
```
./mini-container run --memory 300 sh -c '
x="";
for i in $(seq 1 256); do
  x="$x$(head -c 1M /dev/zero)";
  sleep 0.12;
done;
sleep infinity
'
```


دستور برای گرفتن تمام فضای حافظه رم (در این تست 2 گیگ می باشد.)، اما محدود به 1 گیگ و کرش کردن دستور در انتهای آن برای جلو گیری از مصرف تمام فضای مموری: 


```
./mini-container run --memory 1024 sh -c '
x="";
for i in $(seq 1 2048); do
  x="$x$(head -c 1M /dev/zero)";
  sleep 0.0147;
done;
sleep infinity
'
```


* دستوراات ترکیبی رم و مموری (این دستور یک **تست ترکیبی CPU و RAM** هست و می‌شه گفت “stress test” کانتینره) :
* 
```
./mini-container run --memory 200 --cpu 256 sh -c 'a=""; while true; do a="$a$(printf %0100000d 0)"; done'
```

