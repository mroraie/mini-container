# سیستم مینی کانتینر - گزارش فنی

## ۱. مقدمه

این گزارش فنی پیاده‌سازی سیستم مینی کانتینر مشابه داکر را توصیف می‌کند که به عنوان پروژه درس سیستم‌عامل طراحی شده است. سیستم از C به C++ تبدیل شده و مفاهیم اصلی سیستم‌عامل شامل ایزولاسیون فرایند، مدیریت منابع هسته و فراخوانی‌های سیستمی را نشان می‌دهد، در حالی که روش‌های برنامه‌نویسی مدرن C++ را به نمایش می‌گذارد.

## ۲. معماری سیستم

سیستم به کامپوننت‌های مدولار سازماندهی شده است که هر کدام جنبه خاصی از کانتینری‌سازی را مدیریت می‌کنند. پیاده‌سازی C++ API سازگار با C را برای عملیات سطح سیستم حفظ می‌کند در حالی که ویژگی‌های مدرن C++ را برای بهبود مدیریت حافظه و ایمنی کد معرفی می‌کند.

### ۲.۱ کامپوننت‌های اصلی

- **مدیریت‌کننده کانتینر**: عملیات چرخه حیات کانتینر را هماهنگ می‌کند
- **مدیریت‌کننده فضای نام**: فضای نام لینوکس را برای ایزولاسیون فرایند مدیریت می‌کند
- **مدیریت‌کننده منابع**: محدودیت‌های CPU و حافظه را با استفاده از cgroups کنترل می‌کند
- **مدیریت‌کننده فایل‌سیستم**: ایزولاسیون فایل‌سیستم را از طریق pivot_root فراهم می‌کند
- **رابط CLI**: رابط خط فرمان برای تعامل کاربر
- **وب سرور**: رابط وب برای مانیتورینگ کانتینرها

### ۲.۲ تعامل کامپوننت‌ها

```
رابط CLI
    ↓
مدیریت‌کننده کانتینر ←→ مدیریت‌کننده منابع
    ↓              ←→ مدیریت‌کننده فایل‌سیستم
مدیریت‌کننده فضای نام
```

## ۳. فضای نام لینوکس - ایزولاسیون فرایند

### ۳.۱ مفاهیم فضای نام

فضای نام لینوکس انواع مختلفی از ایزولاسیون را با مجازی‌سازی منابع سیستم فراهم می‌کنند:

- **فضای نام PID**: شناسه فرایندها را ایزوله می‌کند و به هر کانتینر درخت فرایند خود را از PID 1 می‌دهد
- **فضای نام Mount**: نقاط mount فایل‌سیستم را ایزوله می‌کند و امکان جداول mount خصوصی را می‌دهد
- **فضای نام Network**: رابط‌های شبکه، جداول مسیریابی و قوانین فایروال را ایزوله می‌کند
- **فضای نام User**: نگاشت‌های شناسه کاربر و گروه را ایزوله می‌کند

### ۳.۲ جزئیات پیاده‌سازی

مدیریت‌کننده فضای نام از فراخوانی سیستمی `clone()` با پرچم‌های فضای نام استفاده می‌کند:

```cpp
pid_t pid = clone(child_func, stack, CLONE_NEWPID | CLONE_NEWNS, args);
```

جنبه‌های کلیدی پیاده‌سازی:
- **تخصیص پشته**: فرایندهای فرزند نیاز به فضای پشته خود دارند
- **تنظیم فضای نام**: تابع فرزند ایزولاسیون را پس از ایجاد فضای نام پیکربندی می‌کند
- **فضای نام PID**: ایزولاسیون شناسه فرایند از PID 1 فراهم می‌کند
- **فضای نام Mount**: امکان نمایش‌های خصوصی فایل‌سیستم را می‌دهد

### ۳.۳ پیوستن به فضای نام

برای اجرای دستورات در کانتینرهای موجود، سیستم به فضای نام موجود می‌پیوندد:

```c
int namespace_join(pid_t target_pid, int ns_type) {
}
```

## ۴. گروه‌های کنترل (cgroups) - مدیریت منابع

### ۴.۱ مفاهیم Cgroup

گروه‌های کنترل محدودیت‌های سلسله مراتبی منابع و حسابداری فراهم می‌کنند:

- **کنترل CPU**: استفاده از CPU را از طریق shares و quotas محدود می‌کند
- **کنترل حافظه**: استفاده از حافظه را با محدودیت‌های سخت و کنترل swap محدود می‌کند
- **سلسله مراتب**: ساختار درختی امکان کنترل منابع تو در تو را می‌دهد
- **حسابداری**: استفاده از منابع را برای هر گروه ردیابی می‌کند

### ۴.۲ جزئیات پیاده‌سازی

مدیریت‌کننده منابع با فایل‌سیستم `/sys/fs/cgroup` تعامل می‌کند:

```c
// create cgroup
mkdir("/sys/fs/cgroup/cpu/mini_container/container_id", 0755);

// setup CPU shares
FILE *fp = fopen("/sys/fs/cgroup/cpu/mini_container/container_id/cpu.shares", "w");
fprintf(fp, "%d\n", shares);

// add process to cgroup
fp = fopen("/sys/fs/cgroup/cpu/mini_container/container_id/tasks", "w");
fprintf(fp, "%d\n", pid);
```

### ۴.۳ محدودیت‌های منابع

- **CPU Shares**: وزن نسبی برای زمان‌بندی CPU (پیش‌فرض: ۱۰۲۴)
- **CPU Quota**: محدودیت‌های مطلق زمان CPU (میکروثانیه در هر دوره)
- **محدودیت‌های حافظه**: محدودیت‌های سخت حافظه به بایت
- **محدودیت‌های Swap**: کنترل فضای swap

## ۵. ایزولاسیون فایل‌سیستم

### ۵.۱ Pivot Root

سیستم از `pivot_root()` برای ایزولاسیون فایل‌سیستم استفاده می‌کند که روش مدرن‌تر و امن‌تر است:

- **pivot_root()**: امکان unmount کردن فایل‌سیستم ریشه قدیمی را می‌دهد
- **امنیت بیشتر**: نسبت به chroot امن‌تر است
- **کنترل بهتر**: امکان مدیریت کامل فایل‌سیستم ریشه

### ۵.۲ پیاده‌سازی

```c
int fs_setup_pivot_root(const char *new_root, const char *put_old) {
    // mount new root
    mount(new_root, new_root, "bind", MS_BIND | MS_REC, NULL);
    
    // create put_old directory
    mkdir(put_old, 0755);
    
    // pivot root
    syscall(SYS_pivot_root, new_root, put_old);
    
    // change to new root
    chdir("/");
    
    // unmount old root
    umount2(put_old, MNT_DETACH);
    rmdir(put_old);
}
```

### ۵.۳ ایجاد فایل‌سیستم ریشه

سیستم فایل‌سیستم‌های ریشه کانتینر حداقل ایجاد می‌کند:

- دایرکتوری‌های ضروری: `/bin`, `/lib`, `/proc`, `/sys`, `/dev`
- گره‌های دستگاه: `/dev/null`, `/dev/zero`, `/dev/random`
- فایل‌های پیکربندی پایه: `/etc/passwd`, `/etc/group`

## ۶. فراخوانی‌های سیستمی و تعامل با هسته

### ۶.۱ فراخوانی‌های سیستمی اصلی

- **clone()**: فرایندهای جدید را در فضای نام ایجاد می‌کند
- **unshare()**: فرایندهای موجود را به فضای نام جدید منتقل می‌کند
- **pivot_root()**: تعویض ریشه پیشرفته و امن
- **mount()**: عملیات mount فایل‌سیستم

### ۶.۲ رابط مستقیم هسته

بر خلاف داکر، این سیستم به طور مستقیم با موارد زیر تعامل می‌کند:
- `/sys/fs/cgroup` برای مدیریت منابع
- `/proc/<pid>/ns/` برای عملیات فضای نام
- فراخوانی‌های سیستمی بدون تجرید سطح بالا

## ۷. مدیریت چرخه حیات کانتینر

### ۷.۱ وضعیت‌های کانتینر

- **CREATED**: کانتینر تعریف شده اما در حال اجرا نیست
- **RUNNING**: فرایند کانتینر فعال است
- **STOPPED**: فرایند کانتینر خاتمه یافته
- **DESTROYED**: منابع کانتینر پاکسازی شده

### ۷.۲ عملیات چرخه حیات

- **Create**: تنظیم cgroups، فضای نام، فایل‌سیستم
- **Run**: ایجاد و راه‌اندازی بلافاصله کانتینر (Create + Start)
- **Start**: راه‌اندازی فرایند کانتینر با ایزولاسیون (برای کانتینرهای متوقف شده)
- **Stop**: خاتمه فرایند کانتینر به طور graceful
- **Destroy**: پاکسازی همه منابع

### ۷.۳ ذخیره‌سازی پیکربندی

سیستم پیکربندی کانتینرها را ذخیره می‌کند تا امکان restart کانتینرهای متوقف شده فراهم شود:
- **saved_config**: پیکربندی کامل کانتینر در `container_info_t` ذخیره می‌شود
- **Restart**: کانتینرهای متوقف شده می‌توانند با همان پیکربندی قبلی دوباره راه‌اندازی شوند

## ۸. مقایسه با ماشین‌های مجازی

### ۸.۱ کانتینر در برابر VM

| جنبه | کانتینرها | ماشین‌های مجازی |
|-------|-----------|------------------|
| **ایزولاسیون** | ایزولاسیون فرایند سطح هسته | مجازی‌سازی سخت‌افزار |
| **استفاده از منابع** | هسته مشترک، سربار حداقل | سیستم‌عامل کامل برای هر VM |
| **زمان راه‌اندازی** | ثانیه | دقیقه |
| **اندازه ایمیج** | مگابایت | گیگابایت |
| **امنیت** | ایزولاسیون سطح هسته | ایزولاسیون سطح سخت‌افزار |

### ۸.۲ تفاوت‌های کلیدی

- **هسته مشترک**: کانتینرها هسته میزبان را به اشتراک می‌گذارند، VMها هسته خود را دارند
- **فراخوانی‌های سیستمی**: فراخوانی‌های سیستمی کانتینر مستقیماً به هسته میزبان می‌روند
- **کارایی منابع**: کانتینرها سربار منابع حداقل دارند
- **تراکم**: کانتینرهای بسیار بیشتری در هر میزبان نسبت به VMها

## ۹. ملاحظات امنیتی

### ۹.۱ سطوح ایزولاسیون

- **ایزولاسیون فرایند**: فضای نام PID از تداخل فرایند جلوگیری می‌کنند
- **ایزولاسیون فایل‌سیستم**: pivot_root از دسترسی فایل‌سیستم جلوگیری می‌کند
- **ایزولاسیون شبکه**: جداسازی فضای نام شبکه اختیاری
- **ایزولاسیون کاربر**: فضای نام کاربر اختیاری برای جداسازی امتیازات

### ۹.۲ محدودیت‌ها

- **هسته مشترک**: همه کانتینرها هسته یکسانی را به اشتراک می‌گذارند
- **دسترسی روت**: کانتینرها معمولاً به عنوان روت در داخل اجرا می‌شوند
- **بدون مجازی‌سازی سخت‌افزار**: هیچ لایه امنیتی اضافی وجود ندارد

## ۱۰. ویژگی‌های عملکرد

### ۱۰.۱ زمان راه‌اندازی

- **ایجاد کانتینر**: ~۱۰۰ms (تنظیم cgroup و فضای نام)
- **راه‌اندازی فرایند**: ~۱۰ms (فراخوانی سیستمی clone)
- **مجموع**: ~۱-۲ ثانیه برای راه‌اندازی کامل کانتینر

### ۱۰.۲ سربار منابع

- **حافظه**: ~۱-۲MB برای هر کانتینر (سربار فضای نام و cgroup)
- **CPU**: سربار CPU حداقل برای حسابداری منابع
- **دیسک**: استفاده حداقل دیسک برای فایل‌سیستم cgroup

### ۱۰.۳ مقیاس‌پذیری

- **تراکم کانتینر**: محدود به PIDهای موجود و حافظه
- **محدودیت منابع**: cgroups کنترل دانه‌ریز فراهم می‌کنند
- **تعویض زمینه**: همان زمان‌بندی فرایند منظم

## ۱۱. چالش‌های پیاده‌سازی

### ۱۱.۱ چالش‌های فنی

- **هماهنگی فضای نام**: اطمینان از ترتیب صحیح تنظیم فضای نام
- **سلسله مراتب Cgroup**: مدیریت مجوزهای فایل‌سیستم cgroup
- **تنظیم فایل‌سیستم**: ایجاد فایل‌سیستم‌های ریشه حداقل کاربردی
- **همگام‌سازی فرایند**: مدیریت روابط فرایند پدر-فرزند

### ۱۱.۲ ویژگی‌های خاص لینوکس

- **وابستگی به نسخه هسته**: نیاز به ویژگی‌های هسته مدرن
- **امتیازات روت**: اکثر عملیات نیاز به دسترسی روت دارند
- **مجوزهای فایل‌سیستم**: cgroups نیاز به تنظیم mount مناسب دارند

## ۱۲. ویژگی‌های پیاده‌سازی C++

تبدیل به C++ چندین روش برنامه‌نویسی مدرن را معرفی می‌کند در حالی که سازگاری سطح سیستم را حفظ می‌کند:

### ۱۲.۱ مدیریت حافظه
- **اشاره‌گرهای هوشمند**: استفاده از `std::unique_ptr` برای مدیریت خودکار حافظه
- **الگوی RAII**: دستیابی و پاکسازی منابع از طریق عمر اشیاء
- **عملیات حافظه امن**: castهای C++ (`static_cast`, `const_cast`) به جای castهای سبک C
- **مدیریت خطا**: بررسی خطا برای تمام `strdup` و تخصیص‌های حافظه
- **پاکسازی خودکار**: آزادسازی حافظه در مسیرهای خطا

### ۱۲.۲ ویژگی‌های مدرن C++
- **استفاده از STL**: `std::vector`, `std::string`, `std::map` برای مدیریت داده‌ها
- **Lambda Functions**: استفاده از lambda برای callback functions
- **Thread Support**: استفاده از `std::thread` برای وب سرور
- **Atomic Operations**: استفاده از `std::atomic` برای flag های thread-safe

## ۱۳. رابط وب (Web Server)

### ۱۳.۱ معماری وب سرور

سیستم شامل یک وب سرور ساده برای مانیتورینگ کانتینرها است:
- **Thread-based**: اجرا در thread جداگانه
- **HTTP/1.1**: پشتیبانی از پروتکل HTTP/1.1
- **RESTful API**: API های RESTful برای دسترسی به اطلاعات کانتینرها

### ۱۳.۲ Endpoints

- **GET /**: صفحه اصلی مانیتورینگ با نمودارهای CPU و Memory
- **GET /api/containers**: لیست JSON تمام کانتینرهای فعال
- **GET /api/system**: اطلاعات سیستم (CPU, Memory)

### ۱۳.۳ ویژگی‌های مانیتورینگ

- **به‌روزرسانی خودکار**: به‌روزرسانی هر 10 ثانیه
- **نمودارهای تعاملی**: استفاده از Chart.js برای نمایش داده‌ها
- **اطلاعات Real-time**: نمایش استفاده CPU و Memory در زمان واقعی

## ۱۴. مدیریت Signal و Graceful Shutdown

### ۱۴.۱ Signal Handler

سیستم از signal handler برای graceful shutdown استفاده می‌کند:
- **SIGINT (Ctrl+C)**: توقف همه کانتینرها و خروج از برنامه
- **SIGTERM**: توقف همه کانتینرها و خروج از برنامه

### ۱۴.۲ فرآیند Shutdown

1. دریافت signal (SIGINT/SIGTERM)
2. ارسال SIGTERM به همه فرایندهای کانتینرهای RUNNING
3. صبر برای graceful termination
4. تغییر state کانتینرهای RUNNING به STOPPED
5. تغییر state کانتینرهای CREATED به STOPPED
6. Force kill فرایندهای باقی‌مانده (در صورت نیاز)
7. ذخیره state نهایی
8. توقف وب سرور
9. پاکسازی منابع و خروج

## ۱۵. ویژگی‌های تست و مانیتورینگ

### ۱۵.۱ تست مموری و CPU

سیستم شامل قابلیت تست خودکار منابع است:
- **تست مموری**: ایجاد 3 کانتینر با محدودیت‌های 1/16، 1/8 و 1/4 کل مموری سیستم
- **تست CPU**: ایجاد 3 کانتینر با محدودیت‌های 1/16، 1/8 و 1/4 CPU
- **نام‌گذاری**: کانتینرهای تست با نام‌های C1MEM, C2MEM, C3MEM و C1CPU, C2CPU, C3CPU

### ۱۵.۲ مانیتورینگ Real-time

- **CLI Monitor**: نمایش compact monitor در منوی اصلی
- **Full Monitor**: نمایش htop-like monitor با اطلاعات کامل
- **Web Monitor**: مانیتورینگ از طریق رابط وب

## ۱۶. بهبودهای مدیریت حافظه

### ۱۶.۱ مدیریت خطا

- **بررسی strdup**: بررسی خطا برای تمام تخصیص‌های حافظه
- **پاکسازی در خطا**: آزادسازی حافظه در مسیرهای خطا
- **Null Checks**: بررسی NULL قبل از استفاده از اشاره‌گرها

### ۱۶.۲ بهینه‌سازی

- **کاهش Memory Leaks**: رفع تمام memory leaks در error paths
- **مدیریت صحیح**: استفاده از RAII pattern برای مدیریت منابع

## نتیجه‌گیری

این سیستم مینی کانتینر با موفقیت مفاهیم اصلی سیستم‌عامل را نشان می‌دهد:

- **ایزولاسیون فرایند**: از طریق فضای نام لینوکس
- **مدیریت منابع**: از طریق گروه‌های کنترل
- **امنیت فایل‌سیستم**: با استفاده از pivot_root
- **استفاده از فراخوانی‌های سیستمی**: تعامل مستقیم با هسته
- **رابط وب**: مانیتورینگ از طریق وب سرور
- **Graceful Shutdown**: مدیریت صحیح signal ها و توقف کانتینرها
- **مدیریت حافظه**: استفاده از الگوهای مدرن C++ برای مدیریت حافظه

پیاده‌سازی جایگزین سبک و آموزشی برای سیستم‌های کانتینر کامل مانند داکر فراهم می‌کند، در حالی که ویژگی‌های اساسی ایزولاسیون و مدیریت منابع را که کانتینرها را برای استقرار برنامه و ایزولاسیون اجرا مفید می‌کنند، حفظ می‌کند. سیستم همچنین شامل ویژگی‌های پیشرفته‌ای مانند رابط وب، تست خودکار منابع و مدیریت صحیح signal ها است که آن را به یک ابزار کامل برای یادگیری و توسعه تبدیل می‌کند.
